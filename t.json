{
    "id": "703246",
    "timePublished": "2022-12-02T21:54:01+00:00",
    "isCorporative": false,
    "lang": "ru",
    "titleHtml": "Прогнозирование продаж Python. Как находить и сглаживать выбросы с помощью фильтра Хэмплея",
    "leadData": {
        "textHtml": "<p>Те, кто работает с временными рядами, часто сталкивается с двумя проблемами. Первая – нет полных данных. Вторая – битые данные, когда встречается много выбросов, шума и пропусков. Редко встречаются случаи, когда всё было бы идеально. И данных много, и можно легко найти нужные. Такое встретишь крайне редко или почти никогда. </p><p>Возникает вопрос - как решить эту проблему? Я нашёл решение. Давайте расскажу вам, как я решаю проблему битых данных, выбросов, пропусков. Какие я использовал методы, в чем их отличия, преимущества и какие я считаю самыми лучшими. </p><p>Начнём мы с первого метода – фильтра Хэмплея. В этой статье речь пойдёт именно о нём. Я постараюсь как можно проще рассказать о его особенностях и показать всё на наглядных примерах. Приступим.</p>",
        "imageUrl": null,
        "buttonTextHtml": "Читать далее",
        "image": {
            "url": "https://habrastorage.org/getpro/habr/upload_files/0ee/ed5/474/0eeed5474eaa3f7cfdec3d3d41756bbb.jpeg",
            "fit": "cover",
            "positionY": 0,
            "positionX": 0
        }
    },
    "editorVersion": "2.0",
    "postType": "article",
    "postLabels": [
        {
            "type": "sandbox",
            "data": null
        }
    ],
    "author": {
        "id": "3347323",
        "alias": "KainoRhine",
        "fullname": "Вильмов Андрей",
        "avatarUrl": "//habrastorage.org/getpro/habr/avatars/378/77e/85e/37877e85e806cf2b8362e5a200e167e4.jpg",
        "speciality": "Программист(SQL, PHP, Python, ML), Аналитик данных",
        "scoreStats": {
            "score": 1,
            "votesCount": 1
        },
        "rating": 4,
        "relatedData": null,
        "contacts": [],
        "authorContacts": [],
        "paymentDetails": {
            "paymentYandexMoney": null,
            "paymentPayPalMe": null,
            "paymentWebmoney": null
        }
    },
    "statistics": {
        "commentsCount": 1,
        "favoritesCount": 20,
        "readingCount": 784,
        "score": 4,
        "votesCount": 6,
        "votesCountPlus": 5,
        "votesCountMinus": 1
    },
    "hubs": [
        {
            "id": "17795",
            "alias": "bigdata",
            "type": "collective",
            "title": "Big Data",
            "titleHtml": "Big Data",
            "isProfiled": true,
            "relatedData": null
        }
    ],
    "flows": [
        {
            "id": "1",
            "alias": "develop",
            "title": "Разработка",
            "titleHtml": "Разработка"
        }
    ],
    "relatedData": null,
    "textHtml": "<div xmlns=\"http://www.w3.org/1999/xhtml\"><figure class=\"full-width \"><img src=\"https://habrastorage.org/r/w780q1/getpro/habr/upload_files/0ee/ed5/474/0eeed5474eaa3f7cfdec3d3d41756bbb.jpeg\" width=\"1200\" height=\"708\" data-src=\"https://habrastorage.org/getpro/habr/upload_files/0ee/ed5/474/0eeed5474eaa3f7cfdec3d3d41756bbb.jpeg\" data-blurred=\"true\"/><figcaption></figcaption></figure><p>Те, кто работает с временными рядами, часто сталкивается с двумя проблемами. Первая – нет полных данных. Вторая – битые данные, когда встречается много выбросов, шума и пропусков. Редко встречаются случаи, когда всё было бы идеально. И данных много, и можно легко найти нужные. Такое встретишь крайне редко или почти никогда. </p><p>Возникает вопрос - как решить эту проблему? Я нашёл решение. Давайте расскажу вам, как я решаю проблему битых данных, выбросов, пропусков. Какие я использовал методы, в чем их отличия, преимущества и какие я считаю самыми лучшими. </p><p>Начнём мы с первого метода – фильтра Хэмплея. В этой статье речь пойдёт именно о нём. Я постараюсь как можно проще рассказать о его особенностях и показать всё на наглядных примерах. Приступим.</p><h3>Как работает фильтр Хэмплея</h3><p>Для начала стоит понять, что такое фильтр Хэмплея. В интернете о нём вы мало что найдёте. По крайней мере, я встретил лишь скудную информацию. Хотя потратил много времени на поиски нужной информации о фильтре. </p><p>Главная цель Хэмплея – найти и заменить выбросы в заданном временном ряду. Для этого в своей основе он использует скользящее среднее с заданным окном. Для каждой итерации или окна фильтр вычисляет медиану и стандартное отклонение. Оно выражается в среднем абсолютном значении и обозначается как MAD.</p><figure class=\"\"><img src=\"https://habrastorage.org/r/w1560/getpro/habr/upload_files/31d/f3e/0fa/31df3e0fad7031696c3e3f02988ebe2c.png\" alt=\"Материал из вики: https://en.wikipedia.org/wiki/Median_absolute_deviation\" title=\"Материал из вики: https://en.wikipedia.org/wiki/Median_absolute_deviation\" width=\"195\" height=\"20\" data-src=\"https://habrastorage.org/getpro/habr/upload_files/31d/f3e/0fa/31df3e0fad7031696c3e3f02988ebe2c.png\"/><figcaption>Материал из вики: https://en.wikipedia.org/wiki/Median_absolute_deviation</figcaption></figure><p>Чтобы MAD стал последовательной оценкой стандартного отклонения надо умножить его на постоянный коэффициент k. Коэффициент зависит от распределения. Мы считаем, что данные подчиняются распределению Гаусса, поэтому берём коэффициент равным 1,4826.</p><figure class=\"\"><img src=\"https://habrastorage.org/getpro/habr/upload_files/3cc/a3b/ab5/3cca3bab576ed0eb067cf7bb15241c4b.PNG\" width=\"383\" height=\"41\"/><figcaption></figcaption></figure><p>Если значение медианы окна скользящего среднего больше чем <em>х</em> стандартных отклонений, то это – выброс.</p><p>Фильтр Хэмплея имеет 2 настраиваемых параметра:</p><p>·         размер раздвижного окна</p><p>·         количество стандартных отклонений, которые идентифицируют выброс</p><p>Для начала надо импортировать нужные библиотеки:</p><pre><code class=\"python\">import matplotlib.pyplot as plt\nimport warnings\nimport pandas as pd\nimport numpy as np</code></pre><p>Загрузить данные из csv файла:</p><pre><code class=\"python\">df = pd.read_csv('data.csv')</code></pre><p>Распечатать данные</p><pre><code class=\"python\">df.head()</code></pre><p></p><figure class=\"\"><img src=\"https://habrastorage.org/r/w1560/getpro/habr/upload_files/4b5/c17/e13/4b5c17e131b2f7f8f7c7e6dd2acf9962.png\" width=\"251\" height=\"242\" data-src=\"https://habrastorage.org/getpro/habr/upload_files/4b5/c17/e13/4b5c17e131b2f7f8f7c7e6dd2acf9962.png\"/><figcaption></figcaption></figure><p>Вы можете заметить, что выбросы в df уже помечены. Это делается для того, чтобы мы могли сравнить работу алгоритма с фактом. </p><p>Далее визуализируем наш df</p><pre><code class=\"python\">plt.plot(df.x, df.y)\nplt.scatter(df[df.outlier == 1].x, df[df.outlier == 1].y, c='r', label='outlier')</code></pre><p></p><figure class=\"\"><img src=\"https://habrastorage.org/r/w1560/getpro/habr/upload_files/0d4/e9c/3b9/0d4e9c3b922cfda4436436168461448d.png\" width=\"428\" height=\"291\" data-src=\"https://habrastorage.org/getpro/habr/upload_files/0d4/e9c/3b9/0d4e9c3b922cfda4436436168461448d.png\"/><figcaption></figcaption></figure><p>Теперь можно реализовывать фильтр Хэмпеля. Для этого используем 3 стандартных отклонения. Почему именно 3? Потому что этого с лихвой хватит для нашего временного ряда. </p><pre><code class=\"python\">def hampel(y, window_size, simg=3):    \n    n = len(y)\n    new_y = y.copy()\n    k = 1.4826\n    idx = []\n\n    for i in range((window_size),(n - window_size)):\n        r_median = np.median(y[(i - window_size):(i + window_size)]) #скользящая медиана \n        r_mad  = np.median(np.abs(y[(i - window_size):(i + window_size)] - r_median)) #скользящий MAD \n        if (np.abs(y[i] - r_median) > simg * r_mad):\n            new_y[i] = r_median #замена выброса\n            idx.append(i)\n    \n    return new_y, idx</code></pre><p>Вызываем фильтр Хэмплея с окном скользящего среднего равного 3, чтобы определить выброс. Этого будет достаточно для нашей задачи.</p><pre><code class=\"python\">new_y, outliers = hampel(df.y, 3)</code></pre><p>В переменной new_y лежит новый временный ряд без выбросов. В outliers - индексы выбросов во временном ряду.</p><p>Заливаем новый временный ряд в df вместе с признаками выбросов.</p><pre><code class=\"python\">df['new_y'] = new_y\ndf.loc[outliers, 'outlier_hampel'] = 1</code></pre><p>Осталось визуализировать данные.</p><pre><code class=\"python\">from matplotlib.pyplot import figure\nfigure(figsize=(15, 6), dpi=80)\nplt.plot(df.x, df.y)\nplt.plot(df.x, df.new_y)\nplt.scatter(df[df.outlier == 1].x, df[df.outlier == 1].y, c='r', label='outlier')\nplt.scatter(df[df.outlier_hampel == 1].x, df[df.outlier_hampel == 1].y, c='b', label='outlier')</code></pre><p>Выбросы, размеченные вручную, выделяются красным цветом. Синие выбросы – это определение модели. </p><p></p><figure class=\"full-width \"><img src=\"https://habrastorage.org/r/w1560/getpro/habr/upload_files/d42/cd9/e7d/d42cd9e7db8e15f8180c19911482585b.png\" width=\"991\" height=\"396\" data-src=\"https://habrastorage.org/getpro/habr/upload_files/d42/cd9/e7d/d42cd9e7db8e15f8180c19911482585b.png\"/><figcaption></figcaption></figure><p>На графике видно, что красного цвета нет. Вывод – алгоритм работает на отлично. </p><p>Для лучшего понимания возьмём другой временной ряд, чтобы снова проверить алгоритм. </p><p></p><figure class=\"full-width \"><img src=\"https://habrastorage.org/r/w1560/getpro/habr/upload_files/0d5/3c0/ca4/0d53c0ca4f87fa4bd2b379dded702e5c.png\" width=\"991\" height=\"396\" data-src=\"https://habrastorage.org/getpro/habr/upload_files/0d5/3c0/ca4/0d53c0ca4f87fa4bd2b379dded702e5c.png\"/><figcaption></figcaption></figure><p>Здесь заметим, что выбросов гораздо больше. </p><pre><code class=\"python\">new_y, outliers = hampel(df_new.y, 3)\ndf_new['new_y'] = res\ndf_new.loc[detected_outliers, 'outlier_hampel'] = 1\n\nfrom matplotlib.pyplot import figure\nfigure(figsize=(15, 6), dpi=80)\nplt.plot(df_new.x, df_new.y)\nplt.plot(df_new.x, df_new.new_y)\nplt.scatter(df_new[df_new.outlier == 1].x, df_new[df_new.outlier == 1].y, c='r', label='outlier')\nplt.scatter(df_new[df_new.outlier_hampel == 1].x, df_new[df_new.outlier_hampel == 1].y, c='b', label='outlier')</code></pre><p></p><figure class=\"full-width \"><img src=\"https://habrastorage.org/r/w1560/getpro/habr/upload_files/b8d/390/d3f/b8d390d3fbf5305fc446903da8e8937f.png\" width=\"991\" height=\"396\" data-src=\"https://habrastorage.org/getpro/habr/upload_files/b8d/390/d3f/b8d390d3fbf5305fc446903da8e8937f.png\"/><figcaption></figcaption></figure><p>Увеличим окно скользящего среднего.</p><pre><code class=\"python\">new_y, outliers = hampel(df_new.y, 5)\ndf_new['new_y'] = res\ndf_new.loc[detected_outliers, 'outlier_hampel'] = 1\n\nfrom matplotlib.pyplot import figure\nfigure(figsize=(15, 6), dpi=80)\nplt.plot(df_new.x, df_new.y)\nplt.plot(df_new.x, df_new.new_y)\nplt.scatter(df_new[df_new.outlier == 1].x, df_new[df_new.outlier == 1].y, c='r', label='outlier')\nplt.scatter(df_new[df_new.outlier_hampel == 1].x, df_new[df_new.outlier_hampel == 1].y, c='b', label='outlier')</code></pre><p></p><figure class=\"full-width \"><img src=\"https://habrastorage.org/r/w1560/getpro/habr/upload_files/1e7/70e/c36/1e770ec36a5468579df315b33a6aaf05.png\" width=\"991\" height=\"396\" data-src=\"https://habrastorage.org/getpro/habr/upload_files/1e7/70e/c36/1e770ec36a5468579df315b33a6aaf05.png\"/><figcaption></figcaption></figure><p>Видно, что стало гораздо лучше. </p><p>Что касается точности, то она равна 93.33333333333333 %. Я считаю, что это отличный процент. </p><pre><code class=\"python\"> (df_new[df_new.outlier_hampel == 1].shape[0]/df_new[df_new.outlier == 1].shape[0])*100</code></pre><h3>Что в итоге?</h3><p>Фильтр Хэмпеля прекрасно справляется со своей задачей. Его главным преимуществом стала простота реализации. Он может работать быстро как на малых, так и на больших объемах данных. Само собой, есть что улучшить, но в качестве простого и рабочего инструмента фильтр Хэмпеля показывает себя весьма неплохо.</p><p>Но так ли он хорош, если сравнивать его с другими алгоритмами? Например, с тестом Греббса, критерием выбора Рознера и рандомным лесом. Об этом я расскажу в следующих статьях, а в конце сравним результаты работы каждого алгоритма и вынесем окончательный вердикт, что же лучше.</p></div>",
    "tags": [
        {
            "titleHtml": "python"
        },
        {
            "titleHtml": "фильтра Хэмплея"
        },
        {
            "titleHtml": "выбросы"
        },
        {
            "titleHtml": "Поиск выбросов"
        },
        {
            "titleHtml": "временный ряд"
        },
        {
            "titleHtml": "ml"
        }
    ],
    "metadata": {
        "stylesUrls": [],
        "scriptUrls": [],
        "shareImageUrl": "https://habr.com/share/publication/703246/c724466910c4bbb22ab240785b27e3df/",
        "shareImageWidth": 1200,
        "shareImageHeight": 630,
        "vkShareImageUrl": "https://habr.com/share/publication/703246/c724466910c4bbb22ab240785b27e3df/?format=vk",
        "schemaJsonLd": "{\"@context\":\"http:\\/\\/schema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\/\\/habr.com\\/ru\\/post\\/703246\\/\"},\"headline\":\"Прогнозирование продаж Python. Как находить и сглаживать выбросы с помощью фильтра Хэмплея\",\"datePublished\":\"2022-12-03T00:54:01+03:00\",\"dateModified\":\"2022-12-03T00:54:01+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Вильмов Андрей\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\/\\/habrastorage.org\\/webt\\/a_\\/lk\\/9m\\/a_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Те, кто работает с временными рядами, часто сталкивается с двумя проблемами. Первая &ndash; нет полных данных. Вторая &ndash; битые данные, когда встречается много выбросов,...\",\"url\":\"https:\\/\\/habr.com\\/ru\\/post\\/703246\\/#post-content-body\",\"about\":[\"h_bigdata\",\"f_develop\"],\"image\":[\"https:\\/\\/habrastorage.org\\/getpro\\/habr\\/upload_files\\/0ee\\/ed5\\/474\\/0eeed5474eaa3f7cfdec3d3d41756bbb.jpeg\",\"https:\\/\\/habrastorage.org\\/getpro\\/habr\\/upload_files\\/31d\\/f3e\\/0fa\\/31df3e0fad7031696c3e3f02988ebe2c.png\",\"https:\\/\\/habrastorage.org\\/getpro\\/habr\\/upload_files\\/3cc\\/a3b\\/ab5\\/3cca3bab576ed0eb067cf7bb15241c4b.PNG\",\"https:\\/\\/habrastorage.org\\/getpro\\/habr\\/upload_files\\/4b5\\/c17\\/e13\\/4b5c17e131b2f7f8f7c7e6dd2acf9962.png\",\"https:\\/\\/habrastorage.org\\/getpro\\/habr\\/upload_files\\/0d4\\/e9c\\/3b9\\/0d4e9c3b922cfda4436436168461448d.png\",\"https:\\/\\/habrastorage.org\\/getpro\\/habr\\/upload_files\\/d42\\/cd9\\/e7d\\/d42cd9e7db8e15f8180c19911482585b.png\",\"https:\\/\\/habrastorage.org\\/getpro\\/habr\\/upload_files\\/0d5\\/3c0\\/ca4\\/0d53c0ca4f87fa4bd2b379dded702e5c.png\",\"https:\\/\\/habrastorage.org\\/getpro\\/habr\\/upload_files\\/b8d\\/390\\/d3f\\/b8d390d3fbf5305fc446903da8e8937f.png\",\"https:\\/\\/habrastorage.org\\/getpro\\/habr\\/upload_files\\/1e7\\/70e\\/c36\\/1e770ec36a5468579df315b33a6aaf05.png\"]}",
        "metaDescription": "Те, кто работает с временными рядами, часто сталкивается с двумя проблемами. Первая – нет полных данных. Вторая – битые данные, когда встречается много выбросов, шума и пропусков. Редко встречаются...",
        "mainImageUrl": null,
        "amp": true,
        "customTrackerLinks": []
    },
    "polls": [],
    "commentsEnabled": true,
    "rulesRemindEnabled": false,
    "votesEnabled": true,
    "status": "published",
    "plannedPublishTime": null,
    "checked": null,
    "hasPinnedComments": false,
    "isEditorial": false
}